// Generated by Haxe 4.0.0-rc.2+77068e10c

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.lang {
	public sealed class FieldHashConflict {
		
		public FieldHashConflict(int hash, string name, object @value, global::haxe.lang.FieldHashConflict next) {
			this.hash = hash;
			this.name = name;
			this.@value = @value;
			this.next = next;
		}
		
		
		public readonly int hash;
		
		public readonly string name;
		
		public object @value;
		
		public global::haxe.lang.FieldHashConflict next;
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.lang {
	public sealed class FieldLookup {
		
		#pragma warning disable 628
		static FieldLookup() {
			global::haxe.lang.FieldLookup.length = ( global::haxe.lang.FieldLookup.fieldIds as global::System.Array ).Length;
		}
		
		
		public FieldLookup() {
		}
		
		
		protected static int[] fieldIds = new int[]{97, 98, 102, 104, 105, 109, 113, 22175, 23515, 24865, 1821933, 4745537, 4846113, 4849249, 4899635, 4946020, 4949376, 4995541, 4997752, 5144726, 5145602, 5246186, 5343647, 5393365, 5395588, 5442204, 5442212, 5443986, 5594513, 5594516, 5695307, 5741474, 5841808, 5889761, 9373356, 14532012, 16156571, 19004427, 21062850, 25738091, 26061316, 30638662, 35955413, 42740551, 43737796, 52644165, 57219237, 67859985, 68006728, 69718249, 70507503, 75232702, 76061764, 79347384, 83352445, 87367608, 94326179, 96903864, 109329588, 112843575, 116192081, 117802505, 132916898, 133414859, 142002195, 142151465, 142301684, 142605435, 142895325, 152989637, 157772329, 164354652, 169035606, 183541134, 190204025, 192584839, 212892678, 222029606, 229786036, 243225909, 244830897, 247036618, 252173918, 262801146, 265544154, 271957957, 273334730, 287645543, 288167040, 302979532, 328878574, 334695532, 336134320, 338892735, 341784511, 359333139, 374667308, 404153790, 407283053, 426240778, 437335495, 439506047, 444663929, 452737314, 459152924, 476023927, 480085980, 480756972, 497182236, 499574632, 501039929, 520590566, 525508230, 532844442, 534804344, 542823803, 561678025, 563176397, 572311959, 590344996, 596483356, 603245010, 603885322, 607880558, 610723709, 612773114, 625308696, 635393336, 640252688, 651890926, 656005424, 662293508, 675084859, 689395559, 723690193, 724745946, 725031548, 725748315, 727213953, 727535188, 733983705, 742597905, 759635106, 766501982, 772311838, 782495260, 784433846, 790633684, 812216871, 815319309, 821774530, 834174833, 847852583, 860564433, 878103594, 888465489, 910198946, 912522195, 922671056, 925415547, 928763399, 934283999, 937465614, 939361192, 942927226, 944645571, 946786476, 947296307, 985700412, 988919200, 993950564, 995006396, 997465939, 1008670959, 1028467524, 1029017888, 1033373803, 1041537810, 1058556349, 1067353468, 1071652316, 1081428577, 1081429473, 1091869250, 1092023741, 1092322345, 1092664259, 1103409453, 1103412149, 1113806378, 1113806382, 1114501250, 1126036369, 1126037278, 1130117370, 1131760114, 1131842053, 1136381564, 1153313194, 1154932936, 1155848147, 1164821372, 1165937239, 1169594568, 1169897582, 1170195731, 1181037546, 1191633396, 1191829406, 1194225655, 1202718727, 1202920542, 1203032680, 1203215339, 1204816148, 1213610478, 1213952397, 1214305123, 1214453688, 1214607065, 1224700491, 1224901875, 1225098545, 1225397154, 1238832007, 1246878287, 1246881189, 1247076763, 1247572323, 1247723251, 1247875546, 1248019663, 1259962138, 1269206179, 1269254998, 1269259028, 1269755426, 1275922997, 1276009546, 1276551005, 1280013157, 1280208349, 1280345464, 1280549057, 1280845662, 1280893378, 1281090516, 1281091404, 1281093634, 1282943179, 1291235454, 1291438162, 1302870512, 1313416818, 1325203921, 1348037855, 1352643005, 1352786672, 1375141416, 1381630732, 1390578741, 1395555037, 1400771174, 1427864240, 1428431209, 1431819701, 1436316155, 1462163331, 1462366467, 1471347235, 1492589217, 1506215178, 1506824210, 1509834377, 1510930245, 1532710347, 1537812987, 1547539107, 1558158187, 1563501425, 1575652753, 1576149820, 1582403597, 1595738364, 1620824029, 1621420777, 1621516274, 1623148745, 1639293562, 1648581351, 1692511090, 1703715524, 1705629508, 1705778099, 1714983024, 1720573100, 1723805383, 1725829219, 1743047096, 1762523850, 1763375486, 1768164316, 1768617329, 1791539644, 1792589867, 1802071551, 1830310359, 1836776262, 1842171808, 1887857944, 1891834246, 1899010637, 1915412854, 1916009602, 1920787718, 1932118984, 1937159360, 1944494034, 1954803489, 1962040800, 1971260513, 1975830554, 1981972957, 1997185888, 1998756496, 2001678204, 2022294396, 2025055113, 2044931301, 2047240395, 2048392659, 2049945213, 2056840295, 2057814961, 2061363361, 2069598294, 2081384188, 2082268609, 2082469002, 2082663554, 2089909180, 2094598290, 2123232567, 2124033446, 2127021138, 2131770120, 2135079506, 2137849779};
		
		protected static string[] fields = new string[]{"a", "b", "f", "h", "i", "m", "q", "cb", "id", "op", "isGlobal", "__a", "add", "arr", "buf", "cfg", "cur", "dev", "doc", "get", "gid", "ino", "key", "len", "log", "map", "max", "min", "pop", "pos", "run", "set", "uid", "val", "regroup", "resolveClass", "get_pages", "setNumber", "get_bytes", "exitCode", "teardown", "peekAll", "asFuture", "flags", "flush", "match", "compare", "state", "stdin", "failures", "println", "ensure", "remove", "suite", "killed", "filter", "Success", "merge", "report", "hxUnserialize", "target", "update", "stderr", "stdout", "rescue", "classString", "resize", "useCache", "result", "retain", "onError", "warning", "synchronously", "tasks", "exceptionStack", "Continue", "resolver", "setLoop", "get_recurring", "readBytes", "compareArg", "thread", "readInt16", "mtime", "append", "timer", "callStack", "runSlaves", "stream", "methodName", "iterator", "indent", "hxSerialize", "touch", "isBlocking", "lastIndexOf", "isTinkError", "replacer", "hasNext", "formatter", "message", "before", "serializeFields", "reverse", "getLength", "doStep", "upcoming", "nOccupied", "after", "nlink", "insert", "length", "unserializeObject", "noise", "invoke", "bigEndian", "number", "alive", "native", "get_id", "balance", "dirtyPages", "useEnumIndex", "apply", "writeFullBytes", "destroy", "nextRun", "trigger", "writeString", "atime", "postSerialization", "setConfig", "createSlave", "printPos", "serializeString", "exclude", "retrieve", "cleanse", "test_dump", "holds", "doCleanup", "formatError", "Done", "maxInsertSize", "writeUInt16", "readDigits", "pretty", "get_depleted", "normal", "attempt", "records", "value", "Left", "getFreePage", "fieldsString", "blend", "compareArgs", "dissolved", "cachedIndex", "outer", "Errored", "idealize", "prepend", "handle", "cancel", "success", "toString", "owner", "elapsed", "burst", "priority", "hashes", "serializeRef", "scache", "pages", "parts", "bytes", "index", "_eof", "splice", "exists", "asap", "aset", "cache", "bind", "book", "cases", "code", "copy", "data", "date", "done", "exec", "exit", "asSignal", "atNextStep", "get_file", "file", "forEach", "removeLoop", "minBinding", "scount", "schedule", "check", "info", "item", "join", "keys", "kill", "commit", "left", "list", "get_state", "lock", "concat", "make", "clear", "mode", "close", "mute", "name", "next", "nind", "noop", "writeByte", "page", "path", "peek", "color", "prev", "push", "count", "gathered", "rdev", "read", "rest", "root", "execute", "get_size", "get_stat", "doCancel", "recurring", "seek", "size", "sort", "spin", "stat", "step", "stop", "quicksort", "tabs", "test", "ctime", "vals", "work", "write", "registry", "spliceVoid", "include", "writeBytes", "writeInt16", "cachedKey", "readFloat", "pageSize", "handlers", "createEnumIndex", "gather", "delay", "depth", "addStoragePlan", "timeout", "locked", "dirty", "test_create", "delegate", "concatNative", "nBuckets", "className", "createPage", "assertions", "queue", "quote", "resolveEnum", "description", "__unsafe_get", "__unsafe_set", "recordSize", "indexOf", "lookup", "fileName", "iteratorLoop", "unlock", "toDynamic", "activate", "pageNo", "preDeserialization", "regex", "flatMap", "eager", "retainCount", "readByte", "right", "allEnums", "slaves", "delete", "running", "customParams", "params", "tryDelegate", "enter", "_height", "yield", "__get", "__set", "tabString", "error", "__hx_deleteField", "throwSelf", "deserializationHooks", "serialize", "_done", "event", "lineNumber", "serializationHooks", "extra", "suspend", "upperBound", "unshift", "slaveCounter", "depleted", "_keys", "setup", "unserialize", "decompose", "perform", "doPerform", "create", "shash", "get_owner", "shift", "Right", "sizes", "removeMinBinding", "reduce", "slice", "unserializeEnum", "burstCap", "_stat"};
		
		protected static int length;
		
		public static void addFields(int[] nids, string[] nfields) {
			unchecked {
				int[] cids = global::haxe.lang.FieldLookup.fieldIds;
				string[] cfields = global::haxe.lang.FieldLookup.fields;
				int nlen = ( nids as global::System.Array ).Length;
				int clen = global::haxe.lang.FieldLookup.length;
				if (( ( nfields as global::System.Array ).Length != nlen )) {
					throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("Different fields length: ", global::haxe.lang.Runtime.toString(nlen)), " and "), global::haxe.lang.Runtime.toString(( nfields as global::System.Array ).Length)));
				}
				
				bool needsChange = false;
				{
					int[] _g_arr = nids;
					uint _g_idx = ((uint) (0) );
					while (((bool) (( _g_idx < ( _g_arr as global::System.Array ).Length )) )) {
						int i = ((int) (_g_arr[((int) (_g_idx++) )]) );
						if (( global::haxe.lang.FieldLookup.findHash(i, cids, clen) < 0 )) {
							needsChange = true;
							break;
						}
						
					}
					
				}
				
				if (needsChange) {
					lock(typeof(global::haxe.lang.FieldLookup)){
						int[] ansIds = new int[( clen + nlen )];
						string[] ansFields = new string[( clen + nlen )];
						int ci = 0;
						int ni = 0;
						int ansi = 0;
						while (true) {
							if ( ! ((( (( ci < clen )) ? (( ni < nlen )) : (false) ))) ) {
								break;
							}
							
							if (( cids[ci] < nids[ni] )) {
								ansIds[ansi] = cids[ci];
								ansFields[ansi] = cfields[ci];
								ci = ( ci + 1 );
							}
							else {
								ansIds[ansi] = nids[ni];
								ansFields[ansi] = nfields[ni];
								ni = ( ni + 1 );
							}
							
							ansi = ( ansi + 1 );
						}
						
						if (( ci < clen )) {
							global::System.Array.Copy(((global::System.Array) (cids) ), ((int) (ci) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							global::System.Array.Copy(((global::System.Array) (cfields) ), ((int) (ci) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							ansi = ( ansi + (( clen - ci )) );
						}
						
						if (( ni < nlen )) {
							global::System.Array.Copy(((global::System.Array) (nids) ), ((int) (ni) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							global::System.Array.Copy(((global::System.Array) (nfields) ), ((int) (ni) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							ansi = ( ansi + (( nlen - ni )) );
						}
						
						global::haxe.lang.FieldLookup.fieldIds = ansIds;
						global::haxe.lang.FieldLookup.fields = ansFields;
						global::haxe.lang.FieldLookup.length = ansi;
					}
					;
				}
				
			}
		}
		
		
		public static int doHash(string s) {
			unchecked {
				int acc = 0;
				{
					int _g = 0;
					int _g1 = s.Length;
					while (( _g < _g1 )) {
						int i = _g++;
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[i]) ) ) << 1 );
					}
					
				}
				
				return ((int) (( ((uint) (acc) ) >> 1 )) );
			}
		}
		
		
		public static string lookupHash(int key) {
			unchecked {
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ( min + ( (( max - min )) / 2 ) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						return global::haxe.lang.FieldLookup.fields[mid];
					}
					
				}
				
				throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat("Field not found for hash ", global::haxe.lang.Runtime.toString(key)));
			}
		}
		
		
		public static int hash(string s) {
			unchecked {
				if (( s == null )) {
					return 0;
				}
				
				int acc = 0;
				{
					int _g = 0;
					int _g1 = s.Length;
					while (( _g < _g1 )) {
						int i = _g++;
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[i]) ) ) << 1 );
					}
					
				}
				
				int key = ((int) (( ((uint) (acc) ) >> 1 )) );
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				string[] fld = global::haxe.lang.FieldLookup.fields;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				int len = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ((int) (( min + ( ((double) ((( max - min ))) ) / 2 ) )) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						string field = fld[mid];
						if (( field != s )) {
							return  ~ (key) ;
						}
						
						return key;
					}
					
				}
				
				lock(typeof(global::haxe.lang.FieldLookup)){
					if (( len != global::haxe.lang.FieldLookup.length )) {
						return global::haxe.lang.FieldLookup.hash(s);
					}
					
					global::haxe.lang.FieldLookup.fieldIds = global::haxe.lang.FieldLookup.insertInt(global::haxe.lang.FieldLookup.fieldIds, global::haxe.lang.FieldLookup.length, min, key);
					global::haxe.lang.FieldLookup.fields = global::haxe.lang.FieldLookup.insertString(global::haxe.lang.FieldLookup.fields, global::haxe.lang.FieldLookup.length, min, s);
					 ++ global::haxe.lang.FieldLookup.length;
				}
				;
				return key;
			}
		}
		
		
		public static int findHash(int hash, int[] hashs, int length) {
			unchecked {
				int min = 0;
				int max = length;
				while (( min < max )) {
					int mid = ( (( max + min )) / 2 );
					int imid = hashs[mid];
					if (( hash < imid )) {
						max = mid;
					}
					else if (( hash > imid )) {
						min = ( mid + 1 );
					}
					else {
						return mid;
					}
					
				}
				
				return  ~ (min) ;
			}
		}
		
		
		public static void removeInt(int[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = 0;
			}
		}
		
		
		public static void removeFloat(double[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = ((double) (0) );
			}
		}
		
		
		public static void removeDynamic(object[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = null;
			}
		}
		
		
		public static int[] insertInt(int[] a, int length, int pos, int x) {
			unchecked {
				int[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						int[] newarr = new int[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						int[] newarr1 = new int[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					int[] newarr2 = new int[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = x;
				return a1;
			}
		}
		
		
		public static double[] insertFloat(double[] a, int length, int pos, double x) {
			unchecked {
				double[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						double[] newarr = new double[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						double[] newarr1 = new double[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					double[] newarr2 = new double[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = x;
				return a1;
			}
		}
		
		
		public static object[] insertDynamic(object[] a, int length, int pos, object x) {
			unchecked {
				object[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						object[] newarr = new object[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						object[] newarr1 = new object[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					object[] newarr2 = new object[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = ((object) (x) );
				return a1;
			}
		}
		
		
		public static string[] insertString(string[] a, int length, int pos, string x) {
			unchecked {
				string[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						string[] newarr = new string[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						string[] newarr1 = new string[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					string[] newarr2 = new string[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = x;
				return a1;
			}
		}
		
		
		public static global::haxe.lang.FieldHashConflict getHashConflict(global::haxe.lang.FieldHashConflict head, int hash, string name) {
			while (( head != null )) {
				if (( ( head.hash == hash ) && ( head.name == name ) )) {
					return head;
				}
				
				head = head.next;
			}
			
			return null;
		}
		
		
		public static void setHashConflict(ref global::haxe.lang.FieldHashConflict head, int hash, string name, object @value) {
			global::haxe.lang.FieldHashConflict node = head;
			while (( node != null )) {
				if (( ( node.hash == hash ) && ( node.name == name ) )) {
					node.@value = @value;
					return;
				}
				
				node = ((global::haxe.lang.FieldHashConflict) (node.next) );
			}
			
			head = ((global::haxe.lang.FieldHashConflict) (new global::haxe.lang.FieldHashConflict(hash, name, @value, ((global::haxe.lang.FieldHashConflict) (head) ))) );
		}
		
		
		public static bool deleteHashConflict(ref global::haxe.lang.FieldHashConflict head, int hash, string name) {
			if (( head == null )) {
				return false;
			}
			
			if (( ( head.hash == hash ) && ( head.name == name ) )) {
				head = ((global::haxe.lang.FieldHashConflict) (head.next) );
				return true;
			}
			
			global::haxe.lang.FieldHashConflict prev = head;
			global::haxe.lang.FieldHashConflict node = head.next;
			while (( node != null )) {
				if (( ( node.hash == hash ) && ( node.name == name ) )) {
					prev.next = node.next;
					return true;
				}
				
				node = node.next;
			}
			
			return false;
		}
		
		
		public static void addHashConflictNames(global::haxe.lang.FieldHashConflict head, global::Array<object> arr) {
			while (( head != null )) {
				arr.push(head.name);
				head = head.next;
			}
			
		}
		
		
	}
}


